;;; Mazzeo Alessia 899612

;;; FUNZIONI DI CONTROLLO:

;;; is-varpower/1:
(defun is-varpower (vp)
  (and (listp vp)
       (eq 'v (first vp))
       (let ((p (varpower-power vp))
             (v (varpower-symbol vp)))
         (and (integerp p) (>= p 0) (symbolp v)))))

;;; funzioni ausiliarie per is-varpower:

;;; varpower-power/1:
(defun varpower-power (vp)
  (second vp))

;;; varpower-symbol/1:
(defun varpower-symbol (vp)
  (let ((vs (third vp)))
    (and (atom vs) (not (numberp vs)) vs)))

;;; is-monomial/1:
(defun is-monomial (mn)
  (and (listp mn)
       (eq 'm (first mn))
       (let ((mtd (monomial-degree mn))
             (vps (var-powers mn)))
         (and (integerp mtd) (>= mtd 0) (listp vps) (every #'is-varpower vps)))))

;;; funzioni ausiliarie per is-monomial:

;;; monomial-degree/1:
(defun monomial-degree (mn)
  (cond ((and (= (length mn) 4) (eq 'm (first mn)))
         (let ((mtd (third mn)))
           (and (>= mtd 0) mtd)))
        ((is-polynomial mn) nil)
        (t (let ((parsed-m (as-monomial mn)))
             (and parsed-m (>= (third parsed-m) 0) (third parsed-m))))))

;;; var-powers/1:
(defun var-powers (mn)
  (cond ((and (= (length mn) 4) (eq 'm (first mn)))
         (let ((vps (fourth mn)))
           (and (listp vps) vps)))
        ((is-polynomial mn) nil)
        (t (let ((parsed-m (as-monomial mn)))
             (and parsed-m (listp (fourth parsed-m)) (fourth parsed-m))))))

;;; is-polynomial/1:
(defun is-polynomial (p)
  (and (listp p)
       (eq 'poly (first p))
       (let ((ms (monomials p)))
         (and (listp ms) (every #'is-monomial ms)))))

;;; funzioni ausiliarie per is-polynomial:

;;; monomials/1:
(defun monomials (p)
  (if (eq (first p) 'poly) 
      (second p)
    (monomials (convert-p p))))

;;; convert-p/1:
(defun convert-p (poly)
  (cond ((is-polynomial poly)
         (list 'poly (sort-p (monomials poly))))
        ((is-monomial poly)
         (list 'poly (list poly)))
        ((or (atom poly) (eq '* (first poly)))
         (convert-p (as-monomial poly)))
        (t (as-polynomial poly))))

;;; is-zero/1:
(defun is-zero (X)
  (cond ((numberp X) (zerop X))
        ((and (eq (first X) 'm) (zerop (second X))) t)
        ((and (eq (first X) 'poly) (null (second X))) t)
        (t nil)))

;;; as-monomial/1:
(defun as-monomial (e)
  (reduce-m (sort-m (as-ms e))))

;;; funzioni ausiliarie a as-monomial:

;;; as-ms/1:
(defun as-ms (e)
  (cond ((is-num e) (list 'm (eval e) 0 nil))
        ((atom e) (list 'm 1 1 (list (list 'v 1 e))))
        (t (let ((head (first e)) (tail (rest e)))
             (cond ((is-op head)
                    (cond ((equal head '-)
                           (if (listp (second e))
                               (parse-p-neg (second e))
                             (list 'm -1 1 (list 'v 1 (second e)))))
                          ((equal head '*)
                           (if (zerop (get-c tail)) 
                               (list 'm 0 0 nil)
                             (let ((vps (get-vp tail 0)))
                               (list 'm (get-c tail) (first vps) (rest vps)))))
                          ((equal head '+) nil)))
                   ((check-p head)
                    (parse-p head))
                   (t (list 'm 1 1 (list (list 'v 1 head)))))))))

;;; reduce-m/1:
(defun reduce-m (mn)
  (if (null (var-powers mn)) mn
    (let ((vps (var-powers mn))
          (c (monomial-coefficient mn))
          (td (monomial-degree mn)))
      (list 'm c td (reduce-vps vps)))))

;;; sort-m/1:
(defun sort-m (mn)
  (let ((new-var-powers (copy-list (var-powers mn))))
    (list (first mn) (second mn) (third mn)
          (stable-sort new-var-powers 'string< :key 'third))))

;;; is-num/1:
(defun is-num (e)
  (let ((result 
         (ignore-errors (eval e))))
    (and (numberp result) result)))

;;; is-op/1
(defun is-op (operator)
  (member operator '(+ - * /)))

;;; parse-p-neg/1:
(defun parse-p-neg (e)
  (when (check-p e)
    (list 'm -1 (third e) (list 'v (third e) (second e)))))

;;; get-c/1:
(defun get-c (e)
  (if (null e) 1
    (if (is-num (first e))
        (* 1 (eval (first e)) (get-c (rest e)))
      (get-c (rest e)))))

;;; get-vp/2
(defun get-vp (e td)
  (let ((head (first e)) (tail (rest e)))
    (cond ((and (listp head)
                (not (null head))
                (not (zerop (third head)))
                (equal (first head) 'expt))
           (cons (list 'v (third head) (second head)) 
                 (get-vp tail (+ td (third head)))))
          ((and (listp head)
                (not (null head))
                (zerop (third head))
                (equal (first head) 'expt))
           (get-vp tail td))
          ((and (symbolp head) (not (null head)))
           (cons (list 'v 1 head) (get-vp tail (1+ td))))
          ((numberp head) (get-vp tail td))
          ((null head) (list td)))))

;;; check-p/1
(defun check-p (e)
  (and (listp e)
       (equal (first e) 'expt)
       (symbolp (second e))
       (numberp (third e))))

;;; parse-p/1:
(defun parse-p (e)
  (when (check-p e)
    (if (zerop (third e))
        (list 'm 1 0 nil)
      (list 'm 1 (third e) (list 'v (third e) (second e))))))

;;; monomial-coefficient/1
(defun monomial-coefficient (mn)
  (cond ((null mn) 0)
        ((and (= (length mn) 4) (eq 'm (first mn)))
         (let ((coeff (second mn)))
           (and (numberp coeff) coeff)))
        (t (let ((parsed-m (as-monomial mn)))
             (and parsed-m (numberp (second parsed-m)) (second parsed-m))))))

;;; sort-p/2:
(defun sort-p (mns)
  (stable-sort (copy-list mns) #'order-d))

;;; order-d/2
(defun order-d (first-mono rest-monos)
  (let ((degrees (list (monomial-degree first-mono)
                       (monomial-degree rest-monos))))
    (cond ((null first-mono) (not (null rest-monos)))
          ((null rest-monos) nil)
          ((= (first degrees) (second degrees))
           (order-p (var-powers first-mono)
                    (var-powers rest-monos)))
          (t (< (first degrees) (second degrees))))))

;;; order-p/2:
(defun order-p (vars1 vars2)
  (cond ((null vars1) (not (null vars2)))
        ((null vars2) nil)
        (t (let ((v1 (first vars1)) (v2 (first vars2)))
             (cond ((string< (third v1) (third v2)) t)
                   ((string> (third v1) (third v2)) nil)
                   ((and (equal (third v1) (third v2))
                         (= (second v1) (second v2)))
                    (order-p (rest vars1) (rest vars2)))
                   (t (< (second v1) (second v2))))))))

;;; reduce-vps/1:
(defun reduce-vps (vps)
  (if (null vps) nil
    (let ((vp1 (first vps))
          (vp2 (second vps))
          (tail (rest (rest vps))))
      (cond ((null vp2) vps)
            ((equal (varpower-symbol vp1) (varpower-symbol vp2))
             (reduce-vps (cons (list 'v (+ (varpower-power vp1) 
                                           (varpower-power vp2))
                                     (varpower-symbol vp1))
                               tail)))
            (t (cons vp1 (reduce-vps (cons vp2 tail))))))))
